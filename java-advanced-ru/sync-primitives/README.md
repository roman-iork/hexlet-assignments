# Примитивы синхронизации

В предыдущем упражнении наши потоки работали независимо друг от друга. В реальности обычно ситуация иная. Несколько потоков должны одновременно работать с одним ресурсом и менять его. Для этого потоки должны взаимодействовать между собой, должны быть синхронизированы. Представьте ситуацию, что нескольким людям нужно обсудить некоторую проблему. Чтобы обсуждение не превратилось в хаос и люди могли слышать друг друга, одновременно должен говорить только один человек. В программировании же существует специальное понятие – мьютекс. Задача мьютекса – обеспечить, чтобы доступ к разделяемому объекту был в определённое время только у одного потока. Если Поток-1 захватил ресурс, остальные потоки не смогут получить к нему доступ и будут вынуждены ждать, пока Поток-1 не освободит ресурс

## Ссылки

* [Ключевое слово synchronized](https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html)
* [Пример использования ключевого слова synchronized](https://www.baeldung.com/java-synchronized)

## src/main/java/exercise/SafetyList.java

Вам предстоит написать собственную потокобезопасную реализацию листа. Потокобезопасность этого листа заключается в том, что он может исправно функционировать при использовании его из нескольких потоков одновременно. То есть он должен обеспечивать правильный доступ нескольких потоков к разделяемым данным.
Для упрощения наша реализация будет работать только с целыми числами и будет включать далеко не все методы, которые есть в интерфейсе `List`. Для реализации листа используйте массив.

## Задачи

* Допишите содержимое класса `SafetyList`, который представляет собой потокобезопасную реализацию листа. Добавьте в класс необходимые свойства.

* Создайте публичный метод `add()`, который будет добавлять новый элемент в лист. Именно у этого метода мы должны ограничить выполнение. Сделайте так, чтобы метод мог выполняться только одним потоком одновременно.

* Создайте публичный метод `get()`, который будет возвращать элемент листа по его индексу

* Создайте публичный метод `getSize()`, который будет возвращать количество элементов в листе

```java
SafetyList list = new SafetyList();
list.add(5);
list.add(7);
list.get(0); // 5
list.get(1); // 7
list.getSize(); // 2
```

## src/main/java/exercise/ListThread.java

В этом файле мы определим поток, который будет добавлять элементы в лист

## Задачи

* В файле создайте класс `ListThread`, который будет представлять собой поток.
* Определите в классе конструктор, который принимает в качестве аргумента нашу реализацию листа `SafetyList`
* Сделайте так, чтобы при запуске поток добавлял в переданный лист 1000 любых целых чисел. Перед добавлением каждого элемента поток должен спать в течение одной 1 миллисекунды

```java
// Создаём лист
SafetyList list = new SafetyList();

// Создаём поток, передав туда созданный лист
Thread thread = new Thread(new ListThread(list));

// Запускаем поток
thread.start();

// Работает примерно 1 секунду (1000 элементов * 1 мс)

// Дожидаемся его окончания
thread.join();

// Поток добавил в лист 1000 элементов
list.getSize(); // 1000
```

## src/main/java/exercise/App.java

## Задачи

* В методе `main()` создайте экземпляр потокобезопасного листа SafetyList;

* Создайте и запустите два потока, каждый из которых добавит 1000 элементов в созданный лист

* После окончания работы потоков выведите на экран количество элементов в листе

* Запустите приложение при помощи команды `make run` и проверьте количество элементов в листе. Так как мы запустили два потока, каждый из которых добавляет 1000 элементов, итоговое количество элементов должно быть равно 2000.

* Попробуйте убрать синхронизацию из метода `add()` нашего листа. Прежде чем запустить программу, попробуйте ответить на вопрос: сколько элементов будет в листе после окончания работы потоков?

* Запустите приложение несколько раз и изучите получившееся количество элементов. Количество элементов в листе в этом случае нельзя предугадать заранее, но практически наверняка каждый раз оно будет меньше 2000. Как думаете, почему так происходит?

* Перед запуском тестов не забудьте вернуть синхронизацию в метод `add()` нашей реализации листа

### Подсказки

* При реализации метода `add()` листа, вам может пригодиться эта [статья](https://habr.com/ru/post/128269/)
