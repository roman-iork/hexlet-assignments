# Многопоточность

Многопоточность – это свойство платформы (например, операционной системы, виртуальной машины и т. д.) или приложения, состоящее в том, что процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся параллельно. Мы только начинаем знакомиться с многопоточностью и это домашнее задание будет не сложным. В нём не будет Java-кода. Мы проследим, как происходит параллельное выполнение операций на примере работы в командной оболочке. Вам нужно будет повторить описанные действия в терминале и изучить полученные результаты.

Есть много таких задач, которые мы можем решить выполнять параллельно, например скачивание большого количества файлов, декодирование большого количества изображений. Конечно, все эти задачи можно решать и без использования распараллеливания. Но если мы обрабатываем каждый файл параллельно, мы можем получить большое преимущество с точки зрения скорости. В командной оболочке Bash есть несколько инструментов для распараллеливания, которые могут помочь нам в этом.

## Ссылки

* [Утилита GNU Parallel для параллельного выполнения](https://www.gnu.org/software/parallel/parallel_tutorial.html)
* [Установка утилиты GNU Parallel в Ubuntu](https://onstartup.ru/utility/parallel/)
* [Установка утилиты GNU Parallel в MacOS](https://formulae.brew.sh/formula/parallel)
* [Сервис Replit.com - позволяет работать с командной оболочкой в браузере](https://replit.com/new/bash)

## process

Сначала нам нужно создать скрипт, который мы будем выполнять параллельно.

## Задачи

* В файл `process` добавьте следующий код:

  ```bash
  echo "started processing $*.."
  sleep $((2+ RANDOM % 3));
  echo finished processing "$*";
  ```

  Этот скрипт будет имитировать реальную обработку объёмного изображения. Его выполнение будет занимать от 2 до 5 секунд. В качестве аргумента программа будет принимать имя файла, который нужно обработать

## Работа в терминале

* Выполните этот скрипт у себя в терминале, чтобы проверить как он работает:

  ```bash
  ./process 1.jpg
  ```

Выполнение займет некоторое время. Программа не выполняет никаких полезных действий, только сигнализирует о начале и окончании своей работы. Вывод получится такой:

  ```bash
  started processing 1.jpg...
  finished processing 1.jpg
  ```

Базовый способ выполнять операции параллельно в Bash – это использование оператора `&`. Попробуем выполнить обработку двух изображений параллельно.

* Выполните в терминале следующий код и изучите результат:

  ```bash
  ./process 1.jpg & ./process 2.jpg & wait
  ```

  Обработка обоих файлов запустится примерно в одно и то же время и будет проходить параллельно. Поскольку время обработки случайное, вывод может получиться таким:

  ```bash
  started processing 2.jpg..
  started processing 1.jpg..
  finished processing 2.jpg
  finished processing 1.jpg
  ```

  Обратите внимание, что выполнение обработки двух изображений началось практически одновременно. Использование команды `wait` заставит Bash дождаться окончания всех операций.

Мы можем использовать этот подход для параллельной обработки нескольких изображений. Но если изображений много, например сотня, нам не нужно будет запускать обработку всех 100 изображений одновременно. Вместо этого лучше будет обрабатывать изображения партиями по несколько штук, чтобы эффективнее использовать ядра процессора. Наиболее продвинутым инструментом для параллельного запуска является утилита `Parallel`.

* Используя пакетный менеджер своей ОС, установите утилиту GNU Parallel.

* Скопируйте в терминал следующую команду:

  ```bash
  parallel --ungroup --jobs 3 ./process ::: 1 2 3 4 5 6
  ```

  Разберем эту команду подробнее. Опция `–ungroup` позволяет нам проследить процесс работы во время выполнения. Опция `--jobs` задаёт максимальное количество параллельно запущенных работ. Далее мы указываем нашу утилиту, которая будет выполняться параллельно. Через тройное двоеточие `:::` указываем список аргументов, которые будут переданы в утилиту.

* Выполните команду и изучите получившийся результат. Вывод может получиться примерно такой:

  ``` sh
  started processing 1...
  started processing 2...
  started processing 3...
  finished processing 2
  finished processing 3
  started processing 4...
  started processing 5...
  finished processing 1
  started processing 6...
  finished processing 4
  finished processing 5
  finished processing 6
  ```

  Так как мы указали максимальное количество задач в параллели 3, обработка первых трёх изображений началась практически одновременно. Обратите внимание, что утилита не дожидается окончания обработки всей партии из 3 изображений. Как только обработка второго и третьего закончилась, сразу запустилась обработка четвёртого и пятого, не дожидаясь окончания обработки первого. Это позволяет эффективно использовать ресурсы, так как мощности не простаивают в ожидании окончания обработки всей партии.

Если максимальное количество одновременно запущенных работ не указывать, по умолчанию оно будет равно количеству ядер процессора.

* Попробуйте запустить утилиту parallel без опции `--jobs` и проверьте, какое количество процессов у вас будет запущено параллельно:

  ```bash
  parallel --ungroup ./process ::: 1 2 3 4 5 6 7 8 9 10
  ```

  Вывод может получиться такой:

  ```bash
  started processing 1..
  started processing 2..
  started processing 3..
  started processing 4..
  started processing 5..
  started processing 6..
  started processing 7..
  started processing 8..
  finished processing 3
  finished processing 5
  started processing 9..
  started processing 10..
  finished processing 1
  finished processing 4
  finished processing 2
  finished processing 6
  finished processing 7
  finished processing 8
  finished processing 9
  finished processing 10
  ```

## Подсказки

* Если вы используете ОС Windows без WSL и не можете использовать командную строку, воспользуйтесь сервисом Replit.com. В нём вы сможете работать в командной строке в браузере. Из перечня предлагаемых языков выберите Bash и выполняйте приведённые команды.
