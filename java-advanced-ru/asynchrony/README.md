# Асинхронность

Асинхронность в программировании — выполнение процесса в неблокирующем режиме, что позволяет основному потоку программы продолжить обработку.

## Ссылки

* [Класс CompletableFuture – представляет собой отложенный результат асинхронных вычислений](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/concurrent/CompletableFuture.html)
* [Класс Files – содержит статические методы для работы с файлами и директориями](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/nio/file/Files.html)

## src/main/java/exercise/App.java

## Задачи

* Создайте асинхронный публичный статический метод `unionFiles()`. Метод должен асинхронно читать содержимое двух файлов, объединять эту информацию и записывать её в третий файл. Метод принимает три аргумента – пути до файлов в виде строки. Первые два аргумента – пути до файлов-источников, третий – путь до итогового файла. Метод может принимать абсолютный и относительный путь до файлов. Если хотя-бы один из файлов-источников не существует, на экран должно выводиться сообщение о возникшем исключении. Если итоговый файл не существует, он должен быть создан. Метод должен возвращать `CompletableFuture<String>`.

  ```java
  CompletableFuture<String> result = App.unionFiles("file1.txt", "file2.txt", "dest.txt");
  ```

  Конечно, чтение файлов можно выполнить и синхронно. Но представьте, что у нас сложные задачи, которые выполняются длительное время, например конвертация видеофайла. В этом случае, асинхронный, неблокирующий запуск задач позволит нам получить выигрыш.

* В методе `main()`, используя асинхронный метод `unionFiles()`, прочитайте информацию из двух файлов *src/main/resources/file1.txt* и *src/main/resources/file2.txt* и запишите её в третий файл в этой же директории. Имя файла выберите на своё усмотрение.

* Запустите программу при помощи команды `make run`. Убедитесь, что целевой файл создался и он содержит информацию из двух источников.

### Самостоятельная работа

* В классе `App` создайте асинхронный публичный статический метод `getDirectorySize()`, который считает размеры переданной директории не включая поддиректории. Размер директории складывается из размера всех файлов в директории. Метод должен вернуть `CompletableFuture<Long>`.

  ```java
  CompletableFuture<Long> size = App.getDirectorySize("dir/subdir");
  ```

* Напишите тесты, проверяющие работу этого метода.

### Подсказки

* Для обработки возникших в асинхронном коде исключений можно использовать метод [exceptionally()](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/concurrent/CompletableFuture.html#exceptionally(java.util.function.Function))

* Для того, чтобы независимо друг от друга выполнить две задачи, и затем сделать что-то после их выполнения, можно использовать метод [thenCombine()](https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/concurrent/CompletableFuture.html#thenCombine(java.util.concurrent.CompletionStage,java.util.function.BiFunction))
